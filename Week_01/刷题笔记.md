## 刷题笔记

## 1：Two Sum

```python

#给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。  
#  你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
# 法一：
# 直接两层for循环，一个个找及尝试
# 法二：
# 由题意知：target = num[i] +num[j],且i！=j,得num[j] = taget - num[i]
# 如果num【j】存在与nums列表内则满足题意，根据num【j】.index方法反求j
# 当i 不等于j 的时候则满足条件，输出
# 法三：
# 定义一个空字典，将经过四层转换  值 —> 索引—> 值 -> 索引：
# 循环遍历，将num【i】的值转化为i， 当target -num[i]（值）在字典中时，返回值的索引
# 值 —> 索引—> 值 -> 索引 完成转换
# 法一：暴力法
def twoSum(nums: List[int], target: int):
     for i in range(len(nums)):
         for j in range(i + 1, len(nums)):
             if target == (nums[i] + nums[j]) and i != j:
                 return [i, j]
# 法二：逻辑法
def twoSum(nums: List[int], target: int):
    for i in range(len(nums)):
        a = target - nums[i]  # 由target= num[i] + num[j]可得 num[j] = target - num[i]
        if a in nums:  # 如果j在nums里面则代表成立
            j = nums.index(a)
            if i != j:  # 如果两数相等则不满足题意
                return [i, j]
# 法三：哈希映射法
def towSum3(nums: List[int], target: int):
    dict1 = {}
    for i in range(len(nums)):
        if target - nums[i] in dict1:
            return dict1[target - nums[i]], i
        dict1[nums[i]] = i
```

## 11：maxArea

```python
# 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线的 两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
# 说明：你不能倾斜容器，且 n 的值至少为 2。
# 解：S = min(height) * Len
# 由面积公式可知 二者最短的高 * 长, 若想盛最多的水，长最长时，短的高度最高时则为最大的。
# 往中间移， 长在减少，则需二者高度最小木板大于减少的长度
class Solution(object):
    def maxArea(self, height):
        i, j,  S= 0, len(height)-1, 0
        while i < j:
            if height[i] < height[j]:
                S = max(S, (j - i) * height[i])
                i += 1
            else:
                S = max(S, (j - i) * height[j])
                j-= 1
        return S
```



## 70：climbStairs

```python
# 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 
#  每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 
#  注意：给定 n 是一个正整数。 
列举推导
'''
f(1)= 1
f(2) = 2
f(3) = 3
f(4) = f(2) + f（3）
F(n) = F(n -2 ) + F(n - 1)
'''
# 斐波那契数列结论
class Solution(object):
    def climbStairs(self, n):
        from math import pow
        """
        :type n: int
        :rtype: int
        """
        sqrt5 = 5 ** 0.5
        func = pow((sqrt5 + 1) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1)
        return int(func / sqrt5)

```

## 283：moveZore

```python
# 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
#  必须在原数组上操作，不能拷贝额外的数组。 
#  尽量减少操作次数。
# 解题思路：
# 法一：增删法：循环便利，遇到零pop，追加零
# 法二：双指针快慢指针  若遇到零，记录，非零交换
# 法三: 排序+逆序            
       
class Solution(object):
    def moveZeroes(self, nums):
        i = 0
        for j in range(len(nums)):
            if nums[j] != 0:
                nums[i], nums[j] = nums[j], nums[i]
                i += 1
        return nums
    
    
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        nums.sort(key=bool, reverse=True)
        return nums
```

