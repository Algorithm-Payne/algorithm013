# 学习笔记

## Hash算法

### 哈希

（hash）也叫散列。Hash算法，是将一个不定长的输入，通过散列函数变换成一个定长的输出，即散列值。

### 应用

Hash主要应用在数据结构以及密码学领域。

#### **数据结构：**

> 使用Hash算法的数据结构叫做哈希表，也叫散列表，主要是为了提高查询的效率。它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数就是hash function，存放记录的数组叫做哈希表。
>
> 在数据结构中应用时，有时需要较高的运算速度而弱化考虑抗碰撞性，可以使用自己构建的哈希函数。

#### **密码学：**

> 这种hash散列变换是一种单向运算，具有**不可逆性**即不能根据散列值还原出输入信息，因此严格意义上讲**Hash算法是一种消息摘要算法**，不是一种加密算法。常见的hash算法有：SM3、MD5、SHA-1等 。
>
> 在不同的应用场景下，hash函数的选择也会有所侧重。比如在管理数据结构时，主要要考虑运算的快速性，并且要保证hash均匀分布；而应用在密码学中就要优先考虑  抗碰撞性 ，避免出现两段不同明文hash值相同的情况发生。

### 哈希碰撞:

不同的值经过Hash function得到同一值则产生**哈希碰撞**， **防止**哈希碰撞的最有效方法，就是扩大哈希值的取值空间

```
16个二进制位的哈希值，产生碰撞的可能性是 65536 分之一。如果有65537个用户，就一定会产生碰撞。哈希值的长度扩大到32个二进制位，碰撞的可能性就会下降到 4,294,967,296 分之一。

更长的哈希值意味着更大的存储空间、更多的计算，将影响性能和成本。开发者s必须做出抉择，在安全与成本之间找到平衡。
```

#### hash碰撞解决办法：

**1. 开放地址法**

1. 线性探测再散列

2. 二次探测再散列

3. 伪随机探测再散列

   ```
   所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入 。
   
   开放寻址法：Hi=(H(key) + di) MOD m,i=1,2,…，k(k<=m-1)，其中H(key)为散列函数，m为散列表长，di为增量序列，可有下列三种取法：
   
   1)． di=1,2,3,…，m-1，称线性探测再散列；
   
   2)． di=1^2,(-1)^2,2^2,(-2)^2,(3)^2,…，±(k)^2,(k<=m/2)称二次探测再散列；
   
   3)． di=伪随机数序列，称伪随机探测再散列。
   
   用开放定址法解决冲突的做法是：当冲突发生时，使用某种探测技术（线性探测法、二次探测法（解决线性探测的堆积问题）、随机探测法（和二次探测原理一致，不一样的是：二次探测以定值跳跃，而随机探测的散列地址跳跃长度是不定值））在散列表中形成一个探测序列。
   
   沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址（即该地址单元为空）为止插入即可。
   ```

2. **再哈希法**

> 再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数去计算地址，直到无冲突。
> 虽然不易发生聚集，但是增加了计算时间。

3. **链地址法(Java hashmap)**

> 链地址法的基本思想是：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，将所有关键字为同义词的结点链接在同一个单链表中，

4. **建立公共溢出区**

> 建立公共溢出区的基本思想是：假设哈希函数的值域是 [1,m-1]，则设向量 HashTable[0...m-1] 为基本表， 每个分量存放一个记录，另外设向量 OverTable[0...v] 为溢出表，所有关键字和基本表中关键字为同义词的记录，不管它们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。

## 树、二叉树、二叉搜索树

### 树的特征与定义：

```
树是元素的集合。

该集合可以为空。这时树中没有元素，称树为空树 (empty tree)。

如果该集合不为空，那么该集合有一个根节点，以及0个或者多个子树。根节点与它的子树的根节点用一个边(edge)相连。

结点的度（Degree）：结点拥有的子树数称为结点的度（Degree）。度为0的结点称为叶子（Leaf）或终端结点。度不为0的结点称为非终端结点或分支结点。
树的度：是树内各结点的度的最大值。
孩子和双亲：结点的子树的根称为该结点的孩子（Child），相应地，该结点称为孩子的双亲（Parent）。
结点的层次（Level）：是从根结点开始计算起，根为第一层，根的孩子为第二层，依次类推。树中结点的最大层次称为树的深度（Depth）或高度。
如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。
```

### 二叉树

```
二叉树（Binary Tree）的特点是每个结点至多具有两棵子树（即在二叉树中不存在度大于2的结点），并且子树之间有左右之分。

二叉树的性质：
（1）、在二叉树的第i层上至多有2i-1个结点（i≥1）。
（2）、深度为k的二叉树至多有2k-1个结点（k≥1）。
（3）、对任何一棵二叉树，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。
```

### 二叉搜索树

```
# 查找（search）
二叉搜索树的特点是左子节点小于父节点，右子节点大于或等于父节点。查找某个节点时，先从根节点入手，如果该元素值小于根节点，则转向左子节点，否则转向右子节点，以此类推，直到找到该节点，或者到最后一个叶子节点依然没有找到，则证明树中没有该节点
```

```
# 删除（Del）
删除点没有左子树（节点）：
只需要将该节点的父节点和当前节点的有孩子相连即可

删除点有左（节点）:
这种情况下先找到当前节点的左子树的最右节点，因为一个节点的左子树的最右节点也比右子树的最左节点小，把最右节点复制给删除点，然后删除最右节点
```

```
# 插入（insert）
插入一个新节点首先要确定插入的位置，关键思路是确定新节点父节点所在的位置。
```

## 堆（Heap）

可以快速的找到一堆数中的最大或最小值的数据结构,

```
0:根节点
左子堆： 2n + 1
右子堆： 2n + 2
父堆： floor（(n-1)/2）
```

将根节点最大的堆叫做大顶堆（大根堆），根节点最小的堆叫做小顶堆（小根堆）。常见的堆有二叉堆、斐波那契堆、

```
假设是大顶堆，常见的操作方式
find-max： O（1）
delete-max: O(logN)
insert(create): O(logN) or O(1)
```

```
insert
1.插到堆尾
2.维护堆：依次向上调整整个堆的结构（一直到根即可）
delete
1.移除目标数
2.维护堆：依次向上调整整个堆的结构（一直到根即可）

```

## 图

图是一种复杂的非线性结构。

在线性结构中，数据元素之间满足唯一的线性关系，每个数据元素(除第一个和最后一个外)只有一个直接前趋和一个直接后继；

在树形结构中，数据元素之间有着明显的层次关系，并且每个数据元素只与上一层中的一个元素(parent node)及下一层的多个元素(孩子节点)相关；

而在图形结构中，节点之间的关系是任意的，图中任意两个数据元素之间都有可能相关。

**图G由两个集合V(顶点Vertex)和E(边Edge)组成，定义为G=(V，E)**

### 顶点的度

对于**无向图**，顶点的度表示以该顶点作为一个端点的边的数目。比如，图(a)无向图中顶点V3的度D(V3)=3

对于**有向图**，顶点的度分为入度和出度。入度表示以该顶点为终点的入边数目，出度是以该顶点为起点的出边数目，该顶点的度等于其入度和出度之和。比如，顶点V1的入度ID(V1)=1，出度OD(V1)=2，所以D(V1)=ID(V1)+OD(V1)=1+2=3

### 路径、路径长度和回路

路径，比如在无向图G中，存在一个顶点序列Vp,Vi1,Vi2,Vi3…，Vim，Vq，使得(Vp,Vi1)，(Vi1,Vi2)，…,(Vim,Vq)均属于边集E(G)，则称顶点Vp到Vq存在一条路径。

一系列顶点构成路径，路径中所有顶点都由边连接。

路径长度，是指一条路径上经过的边的数量。

回路，指一条路径的起点和终点为同一个顶点。

### 图的两种存储结构（表示图）

图和树或者二叉树很像，尝试用树的方式来创建一个图类，用节点来表示每个顶点。但这种情况下，如果用基于对象的方式去处理就会有问题，因为图可能增长到非常大。 用对象来表示图很快会变得效率低下，所以要考虑表示顶点或边的其他方案。

#### 表示顶点

创建图类的第一步是要创建一个Vertex类保存顶点和边。这个类的作用与链表和二叉搜索树的Node类一样。Vertex类有两个数据成员： 一个用于标识顶点，另一个是表示这个顶点是否被访问过的布尔值。分别命名为label 和 wasVisited.这个类只需要一个函数，那就是为顶点的数据成员设定值的构造函数。

#### 表示边

图的实际信息都保存在边上，因为它们描述了图的结构。容易像之前提到的那样用二叉树的方式去表示图，这是不对的。二叉树的表现形式相当固定，一个父节点只能有两个子节点，而图结构却要灵活的多，一个顶点既可以有一条边，也可以有多条边与它相连。

将表示图的边的方法称为`邻接表` 或者邻接表数组。

这种方法将边储存为`由顶点的相邻顶点列表构成的数组`，并以此顶点作为索引。

> **邻接矩阵**
>
> 原理就是用两个数组，一个数组保存顶点集，一个数组保存边集。下面的算法实现里边我们也是采用这种存储结构。如下图所示：

> **邻接表**
>
> 邻接表是图的一种链式存储结构。这种存储结构类似于树的孩子链表。对于图G中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的邻接表。

## 图的两种遍历方法

#### 深度优先搜索DFS遍历类似于树的前序遍历。其基本思路是：

> a) 假设初始状态是图中所有顶点都未曾访问过，则可从图G中任意一顶点v为初始出发点，首先访问出发点v，并将其标记为已访问过。
>
> b)然后依次从v出发搜索v的每个邻接点w，若w未曾访问过，则以w作为新的出发点出发，继续进行深度优先遍历，直到图中所有和v有路径相通的顶点都被访问到。
>
> c) 若此时图中仍有顶点未被访问，则另选一个未曾访问的顶点作为起点，重复上述步骤，直到图中所有顶点都被访问到为止。

**深度优先搜索包括从一条路径的起始点开始追溯，直到到达最后一个顶点，然后回溯，继续追溯下一条路径，直到到达最后的顶点，如此往复，直到没有路径为止**

#### **深度优先搜索：**

> 访问一个没有访问过的顶点，将它标记为已访问，再递归地去访问在起始点的邻接表中其他没有访问过的顶点。